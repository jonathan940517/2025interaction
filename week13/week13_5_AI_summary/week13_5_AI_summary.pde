// =======================================================
//  資料結構：炸彈
// =======================================================
class Bomb {
  int gx, gy;          // 位於地圖格子座標
  int startTime;       // 放置時間
  boolean playerLeft;  // 玩家是否已離開該炸彈所在格子

  Bomb(int gx, int gy) {
    this.gx = gx;
    this.gy = gy;
    this.startTime = millis();
    this.playerLeft = false;
  }
}


// =======================================================
//  全域常數（設定）
// =======================================================
final int TILE = 30;
final int GRID = 20;


// =======================================================
//  全域變數
// =======================================================
int playerX, playerY;      // 玩家像素位置
int playerGX, playerGY;    // 玩家格子座標
int dx = 0, dy = 0;        // 玩家移動向量
int nextGX, nextGY;        // 預測移動後的格子座標

ArrayList<Bomb> bombs = new ArrayList<Bomb>();

// 地圖：0 空地，1 石頭，2 炸彈，3 軟牆
int [][] walls = {  
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0},
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
  {0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
  {0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3},
  {0,1,1,1,1,1,1,0,3,0,0,0,0,1,1,1,1,1,1,0},
  {0,1,1,1,1,1,1,0,3,0,0,0,0,1,1,1,1,1,1,0},
  {0,1,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0},
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
  {0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
  {0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
};


// =======================================================
//  初始化
// =======================================================
void setup() {
  size(600, 600);
  playerX = 300;
  playerY = 300;
}


// =======================================================
//  主迴圈
// =======================================================
void draw() {

  // 更新玩家格子座標
  playerGX = playerX / TILE;
  playerGY = playerY / TILE;

  // 計算下一步格子
  nextGX = (playerX + dx) / TILE;
  nextGY = (playerY + dy) / TILE;

  updatePlayerLeave();
  updateBombs();

  background(150);
  drawMap();

  // ⭐ 使用 BlockX/BlockY 決定可不可以走
  if (canMovePlayer(nextGX, nextGY)) {
    playerX += dx;
    playerY += dy;
  }

  drawPlayer();
}


// =======================================================
//  地圖繪製
// =======================================================
void drawMap() {
  for (int x=0; x<GRID; x++) {
    for (int y=0; y<GRID; y++) {

      switch (walls[x][y]) {
        case 1: fill(255); break;          // 石頭
        case 2: fill(255,255,0); break;    // 炸彈
        case 3: fill(255,0,255); break;    // 軟牆
        default: continue;
      }

      rect(x*TILE, y*TILE, TILE, TILE);
    }
  }
}


// =======================================================
//  玩家繪製
// =======================================================
void drawPlayer() {
  ellipse(playerX, playerY, 12, 12);
}


// =======================================================
//  移動判斷：BlockX/BlockY（下一格）
// =======================================================
boolean canMovePlayer(int gx, int gy) {

  // 邊界
  if (gx < 0 || gx >= GRID || gy < 0 || gy >= GRID) return false;

  // 牆壁阻擋
  if (walls[gx][gy] == 1) return false;

  // 空地可走
  if (walls[gx][gy] == 0) return true;

  // ⭐ 處理炸彈（最重要）
  if (walls[gx][gy] == 2) {

    for (Bomb b : bombs) {

      // 如果目標格是炸彈，而且玩家剛好站在那顆炸彈格 → 可離開
      if (b.gx == playerGX && b.gy == playerGY && b.playerLeft == false) {
        return true;
      }
    }

    // 其他情況不能走進炸彈
    return false;
  }

  return false;
}


// =======================================================
//  判斷玩家是否離開炸彈格
// =======================================================
void updatePlayerLeave() {
  for (Bomb b : bombs) {
    if (b.gx != playerGX || b.gy != playerGY) {
      b.playerLeft = true;
    }
  }
}


// =======================================================
//  放置炸彈
// =======================================================
void placeBomb() {
  Bomb b = new Bomb(playerGX, playerGY);
  walls[playerGX][playerGY] = 2;
  bombs.add(b);
}


// =======================================================
//  更新炸彈（倒數 → 爆炸）
// =======================================================
void updateBombs() {
  for (int i=bombs.size()-1; i>=0; i--) {
    Bomb b = bombs.get(i);

    if (millis() - b.startTime >= 2000) {
      explode(b.gx, b.gy);
      bombs.remove(i);
    }
  }
}


// =======================================================
//  爆炸邏輯
// =======================================================
int bombRange = 2;

void explode(int gx, int gy) {

  walls[gx][gy] = 0;

  int[][] dir = {{1,0},{-1,0},{0,1},{0,-1}};

  for (int[] d : dir) {

    for (int i=1; i<=bombRange; i++) {

      int nx = gx + d[0]*i;
      int ny = gy + d[1]*i;

      if (nx < 0 || nx >= GRID || ny < 0 || ny >= GRID) break;

      if (walls[nx][ny] == 3) { // 軟牆
        walls[nx][ny] = 0;
        break;
      }
    }
  }
}


// =======================================================
//  操作控制
// =======================================================
void keyPressed() {
  if (keyCode == LEFT) dx = -1;
  if (keyCode == RIGHT) dx = 1;
  if (keyCode == UP) dy = -1;
  if (keyCode == DOWN) dy = 1;

  if (key == ' ') placeBomb();
}

void keyReleased() {
  if (keyCode == LEFT || keyCode == RIGHT) dx = 0;
  if (keyCode == UP || keyCode == DOWN) dy = 0;
}
